# Глава 2. Стил на програмата и Рекурсия

Цел: Да се придобие по-добра престава как трябва да се форматират програмите и да се придобие разбиране за рекурсия.

## Стил на програмата
Някой път човек се обърква между всички скоби и имена на променливи, затова е важно да спазваме някакви общи правила, за да може да си раазбираме по-добре програмите

### Начало на файла
\#lang racket - Това ни предоставя възможноста да ползваме пълната функционалност на racket. Пишете го, ако не ви се добавя автоматично.


### Наименувание на променливи
Имената на променливите трябва да се изписват с малки латински буки, пълни думи с тирета
Пример за грешно изписване
<pre id="code1" class="prettyprint lang-lisp">
    (define peopleCnt 3) ;; people count
</pre>

Пример за коректно изписване
<pre id="code1" class="prettyprint lang-lisp">
    (define people-conut 3) ;; people count
</pre>

### Предикати
Функции които връщат или истина, или лъжа трябва задължително да завършват ?. 
Примери: zero?, even?, odd?

### Идентация
Всеки блок трябва да е с един таб навътре, изключение са само аргументите на функции и конструкцията за if, където двата бранча трябва да са на една линия. Като ориентир, кога трява да цъкнете enter, е на около ред с 80 символа.

### Коментари
Ако искате да коментирата информация за файл, ползвайте `;;;` 3 - точки със запетаи
Ако искате да коментирате информация за функции и променливи, ползвайте `;;` 2 - точки със запетаи
Ако искате да коментирате инфоация само за 1 ред, ползвайте `;` 1 - точка със запетая

## Примитивна срещу Опашкова рекурсия
Реукурсията, която сме свикнали да пишем обикновенно е примитивната ето и един пример
<pre id="code1" class="prettyprint lang-lisp">
    (define (factoriel-primitive n) (if (zero? n) 1 (* n (factoriel-primitive (- n 1)))))
</pre>

И нека сега разгледаме едно изпълнение на тази функция примерно
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-primitive 5)
</pre>

Което може да разгънем изпълнението на функцията по следния начин:
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-primitive 5)
    (if (zero? 5) 1 (* 5 (factoriel-primitive (- 5 1))))
    (* 5 (factoriel-primitive (- 5 1)))
    (* 5 (factoriel-primitive 4))
    (* 5 (* 4 (factoriel-primitive 3)))
    (* 5 (* 4 (* 3 (factoriel-primitive 3))))
    (* 5 (* 4 (* 3 (* 2 (factoriel-primitive 1)))))
    (* 5 (* 4 (* 3 (* 2 (* 1 (factoriel-primitive 0))))))
    (* 5 (* 4 (* 3 (* 2 (* 1 (if (zero? 0) 1 (* 0 (factoriel-primitive (- 0 1)))))))))
    (* 5 (* 4 (* 3 (* 2 (* 1 1)))))
    (* 5 (* 4 (* 3 (* 2 1))))
    (* 5 (* 4 (* 3 2)))
    (* 5 (* 4 6))
    (* 5  24)
    120
</pre>
Тук лесно се вижда как с увеличаването на аргумента, расте и паметта, която ни е нужна, за да изпълним програмата. Това наричаме примитивна рекурсия, защото има отложени операции.

Сега нека да разгледаме втора имплементация на същата функция
<pre id="code1" class="prettyprint lang-lisp">
    (define (factoriel-tail n a) (if (zero? n) a (factoriel-tail (- n 1) (* a n))))
</pre>

Като нека сега разгледаме едно примерно изпълнение на тази функция.
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-tail 5 1)
</pre>
Като може да разгънем изпълнението на функцията по следния начин.
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-tail 5 1)
    (if (zero? 5) 1 (factoriel-tail (- 5 1) (* 1 5)))
    (factoriel-tail (- 5 1) (* 1 5))
    (factoriel-tail 4 5)
    (factoriel-tail 3 20)
    (factoriel-tail 2 60)
    (factoriel-tail 1 120)
    (factoriel-tail 0 120)
    (if (zero? 0) 120 (factoriel-tail (- 0 1) (* 120 0)))
    120
</pre>
Тук ясно се вижда че при този подход паметта не расте линейно според входа, а е константна

Втория подход наричаме опашкова рекурсия, заради липсата на отложени операции, или още познат като опашкова рекурсия.

### Реален пример от racket показващ разликата
Изпълнете следните 4 функции и вижте коя не успява да се изпълни успешно
<pre id="code1" class="prettyprint lang-lisp">
    (define (1+-primitive-arg a) (+ 1 (1+-primitive a)))

    (define (1+-tail-arg a) (1+-tail (+ 1 a)))

    (define (1+-primitive) (+ 1 (1+-primitive)))

    (define (1+-tail) (1+-tail))
</pre>

# Задачи.
1. Напишете функцията (palindrome? x) която връща дали дадено число е палиндром.
2. Намерете сумата на затворен интервал, направете го чрез примитивна и опашкова рекурсия.
3. Напишете двете функции, които намират дали едно число е просто
(prime?-prim a) - с примитивна рекурсия
prime?-tail - с опашкова рекурсия
4. Напишете функция, която от двоични превръща в десетични числа 
`(binary->decimal a)`
5. Разменете една от цифирите на дадено число на специфична позиция с опашкова или примитивна рекурсия.
6. Обърнете едно число наобратно. Направете го с примитивна или опашкова рекурсия.
7. Проверете дали едно число a съдържа в края си друго число b.
8. Проверете дали от числото a, цифра на позиция µ е равна на цифра от числото b на позиция ß.
9. Напишете програма, която намира разтояние на Левенщайн между две числа.
