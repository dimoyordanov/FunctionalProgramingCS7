# Глава 2. Стил на програмата и Рекурсия

## Стил на програмата
Някой път човек се обърква между всички скоби и имена на променливи, затова е важно да спазваме някакви общи правила, за да може да си раазбираме по-добре програмите

### Начало на файла
\#lang racket - Това ни предоставя възможноста да ползваме пълната функционалност на racket. Пишете го, ако не ви се добавя автоматично.


### Наименувание на променливи
Имената на променливите трябва да се изписват с малки латински буки, пълни думи с тирета
Пример за грешно изписване
<pre id="code1" class="prettyprint lang-lisp">
    (define peopleCnt 3) ;; people count
</pre>

Пример за коректно изписване
<pre id="code1" class="prettyprint lang-lisp">
    (define people-conut 3) ;; people count
</pre>

### Предикати
Функции които връщат или истина, или лъжа трябва задължително да завършват ?. 
Примери: zero?, even?, odd?

### Идентация
Всеки блок трябва да е с един таб навътре, изключение са само аргументите на функции и конструкцията за if, където двата бранча трябва да са на една линия. Като ориентир, кога трява да цъкнете enter, е на около ред с 80 символа.

### Коментари
- Ако искате да коментирата информация за файл, ползвайте `;;;` 3 - точки със запетаи
- Ако искате да коментирате информация за функции и променливи, ползвайте `;;` 2 - точки със запетаи
- Ако искате да коментирате инфоация само за 1 ред, ползвайте `;` 1 - точка със запетая

## Примитивна срещу Опашкова рекурсия
Реукурсията, която сме свикнали да пишем обикновенно е примитивната ето и един пример
<pre id="code1" class="prettyprint lang-lisp">
    (define (factoriel-primitive n) (if (zero? n) 1 (* n (factoriel-primitive (- n 1)))))
</pre>

И нека сега разгледаме едно изпълнение на тази функция примерно
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-primitive 5)
</pre>

Което може да разгънем изпълнението на функцията по следния начин:
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-primitive 5)
    (if (zero? 5) 1 (* 5 (factoriel-primitive (- 5 1))))
    (* 5 (factoriel-primitive (- 5 1)))
    (* 5 (factoriel-primitive 4))
    (* 5 (* 4 (factoriel-primitive 3)))
    (* 5 (* 4 (* 3 (factoriel-primitive 3))))
    (* 5 (* 4 (* 3 (* 2 (factoriel-primitive 1)))))
    (* 5 (* 4 (* 3 (* 2 (* 1 (factoriel-primitive 0))))))
    (* 5 (* 4 (* 3 (* 2 (* 1 (if (zero? 0) 1 (* 0 (factoriel-primitive (- 0 1)))))))))
    (* 5 (* 4 (* 3 (* 2 (* 1 1)))))
    (* 5 (* 4 (* 3 (* 2 1))))
    (* 5 (* 4 (* 3 2)))
    (* 5 (* 4 6))
    (* 5  24)
    120
</pre>
Тук лесно се вижда как с увеличаването на аргумента, расте и паметта, която ни е нужна, за да изпълним програмата. Това наричаме примитивна рекурсия, защото има отложени операции.

Сега нека да разгледаме втора имплементация на същата функция
<pre id="code1" class="prettyprint lang-lisp">
    (define (factoriel-tail n a) (if (zero? n) a (factoriel-tail (- n 1) (* a n))))
</pre>

Като нека сега разгледаме едно примерно изпълнение на тази функция.
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-tail 5 1)
</pre>
Като може да разгънем изпълнението на функцията по следния начин.
<pre id="code1" class="prettyprint lang-lisp">
    (factoriel-tail 5 1)
    (if (zero? 5) 1 (factoriel-tail (- 5 1) (* 1 5)))
    (factoriel-tail (- 5 1) (* 1 5))
    (factoriel-tail 4 5)
    (factoriel-tail 3 20)
    (factoriel-tail 2 60)
    (factoriel-tail 1 120)
    (factoriel-tail 0 120)
    (if (zero? 0) 120 (factoriel-tail (- 0 1) (* 120 0)))
    120
</pre>
Тук ясно се вижда че при този подход паметта не расте линейно според входа, а е константна

Втория подход наричаме опашкова рекурсия, заради липсата на отложени операции, или още познат като опашкова рекурсия.

### Реален пример от racket показващ разликата
Изпълнете следните 4 функции и вижте коя не успява да се изпълни успешно
<pre id="code1" class="prettyprint lang-lisp">
    (define (1+-primitive-arg a) (+ 1 (1+-primitive a)))

    (define (1+-tail-arg a) (1+-tail (+ 1 a)))

    (define (1+-primitive) (+ 1 (1+-primitive)))

    (define (1+-tail) (1+-tail))
</pre>
## Define
<pre id="code1" class="prettyprint lang-lisp">
    ....A....
    (define (f)
        (define (t1 ... ) [ ..B..])
        (define (x ... ) [ ..C..])
        (define (t2 ... ) [ ..D..])
        ....E....)
    ....F....
</pre>
Тук x е валидно за ползване, само в `E`, `C` и `D` и никъде другаде

## Lambda/Анонимни функции
Анонимните функции или Lambda функции са много удобни за ползване, когато ползваме дадена функци на едно място и не е нужно да и даваме име

Пример.
<pre id="code1" class="prettyprint lang-lisp">
    (define (1+ x) (+ 1 x))
    (define 1+ (lambda (x) (+ 1 x)))
</pre>
И всъщност горното е синтактична захар за долното.

Ето и още няколко примера за lambda функции
<pre id="code1" class="prettyprint lang-lisp">
    (define id (lambda (x) x))
    (define evenl? (lambda (x) (even? x)))
</pre>
## Функции от по-висок ред
Функциите в Scheme са first-class обекти, това означава че към тях интерпретатора се държи всякаш са вградени обекти, както числата или булевите стойноси.

Пример за функционално представяне на числа
<pre id="code1" class="prettyprint lang-lisp">
    (define (init-counter x) (lambda (f) (f x)))
    (define (add-counter c) (lambda (f) (f (c f))))
    (define (execute-counter c f) (c f))
</pre>




# Задачи.
1. Напишете функцията (palindrome? x) която връща дали дадено число е палиндром.
2. Намерете сумата на затворен интервал, направете го чрез примитивна и опашкова рекурсия.
3. Напишете двете функции, които намират дали едно число е просто
(prime?-prim a) - с примитивна рекурсия
prime?-tail - с опашкова рекурсия
4. Напишете функция, която от двоични превръща в десетични числа 
`(binary->decimal a)`
5. Разменете една от цифирите на дадено число на специфична позиция с опашкова или примитивна рекурсия.
6. Напишете функция изпълняващи операцията композиция на 2 функции. `(compose a b)`
    Напишете функция с 1 аргумент a която връща функция с 1 аргумент b, която при произволен вход b връща а `(const a)`
    Напишете функция 1+, която добавя 1 към вход някакво число. `(1+ a)`
7. Напишете функциите accumulate
    Аргумените на функциите accumulate са op: $A\time A \to A$, acc: $A$, a: $A$, b: $A$, f: $A\to A$, next: $A\to A$
    и има следното рекурсивно викане accumulate(op, op(init, f(a)), next(a), b, f, next).
    Дъното на рекурсивното викане е когато a и b се пресекат, принципно a е по-малко от b.
    Пробвайте се да го направите с опашкова и примитивна рекурсия
8. Напишете функция, която събира всички числа в някакъв диапазон, ползвайте accumulate: `(sum-range a b)`
9. Напишете функция, която смята хармоничния ред, до n-тия член $\sum_{i=1}^n \frac{1}{n}$. Ползвайте accumulate `(harmonic n)`
    Напишете функция, която смята следната сума, до n-тия член $\sum{i=1}^n \frac{1}{n^2}$. Ползвайте accumulate `power-two-sequnce n`
10. Напишете функция, която връща истина ако за даден диапазон поне една стойност спазва даден предикат. `(number-any p a b)`
    Напишете функция, която връща истина ако за даден диапазон всяка една стойност спазва даден предикат. `(number-all p a b)`
11. Пребройте, колко числа в даден диапазон спазват даден предикат p. `(count-predicate p a b)`
12. Напишете функция, която връща дали едно число е просто, ползвайте accumulate `(prime? a)`
13. Напишете функция, която композира n пъти функцията f, които се подават като аргументи, ползвайте accumulate. `(repeat f n)`
14. Напишете функцията twist, която редува композиция на функциите f и g, n пъти. Тоест `(twist f g n) = (f o g)( (f o g)( (f o g) ... и така n-пъти))))`

Допълнителни
- Обърнете едно число наобратно. Направете го с примитивна или опашкова рекурсия.
-  Проверете дали едно число a съдържа в края си друго число b.
- Проверете дали от числото a, цифра на позиция µ е равна на цифра от числото b на позиция ß.
- Напишете програма, която намира разтояние на Левенщайн между две числа.
