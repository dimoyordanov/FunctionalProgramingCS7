Задачи: 

1. Напишете функция flatten, която при подаден дуълбок масив връща масив със същите елементи, но в едномерен масив. 
`(flatten deep)`
2. Имплементирайте добавяне и взимане на елемент от асоциативен списък

`(add-assoc map key value)`

`(get-assoc map key)`
3. Имплементирайте махане и проверка за празен асоциативен списък

Бонус: Направете проверка дали въоще подадения обект е асоциативен списък

`(empty-assoc? map)`

`(remove-assoc map key)`

4. Напишете процедура, която връща ключовете на асоциативния списък

Стойностите на социативния списък 

Наредените двойки в асоциативния списък, като списъци

`(keys map2)`

`(vals map2)`

`(items map2)`
5. Напишете процедура, която обединява два асоциативни спиъка, ако има конфликт винаги избира левия масив.

Бонус: добавете функция, която решава как да се процедира при конфликти, тоест какъв елемт да се добави

`(assoc-merge l1 l2 f)`

6. 1. Имплементирайте добавяне и проверка на съседите на връх в граф

`(add-vertex graph vertex)`

`(get-vertex graph vertex)`

7. Имплементирайте махане на връх от граф.

Имплементирайте процедура, която връща всички върхове в графа.

`(remove-vertex graph vertex)`

`(vertexes graph)`

8. Имплементирайте процедура, която казва дали два върха са свързани.

`(edge? graph  a b)`

9. Имплементирайте процедуре, която променя графа, така че на всеки връх да съответства как
`(color-graph graph fcolor)`


10. Бонус
- Имплементирайте детерминиран краен автомат
  - Трябва да включва следни функции
  - `(add-state automaton q)` добаввя се празно състояние
  - `(set-start automaton s)` определя се началното състояние
  - `(set-final auutomaton fin)` определят се крайните състояния
  - `(add-transition automaton a b c)` От състояние `a` към състояние `b` с буква `c`
  - `(next automaton a c)` Следващото състояние след a с буква c
  - `(delta* automaton str)` изпълнението на списъка от символи върху автомата
- Имплементирайте детерминиран стеков автомат
  - Трябва да включва следни функции
  - `(add-state automaton q)` добаввя се празно състояние
  - `(set-start automaton s)` определя се началното състояние
  - `(set-final auutomaton fin)` определят се крайните състояния
  - `(add-transition automaton a b c d)` От състояние `a` към състояние `b` с буква `c` и се добавя към стека списъка d, ако той е празен значи се попва от стека, ако не е празен се замества с върха, размера му е до две променливи
  - `(next automaton a c)` Следващото състояние след a с буква c
  - `(delta* automaton str)` изпълнението на списъка от символи върху автомата
