# Глава 1. Типове данни и прости операции

Цел: въведение в Racket

Допускам че сте успели да изтеглите Dr. Racket, ако не това е първа стъпка в увода в racket. Ако не може да го направите от [тук](https://racket-lang.org/)

## Типове данни
Racket има подобни типове както тези които имахме в увод в програмирането и обектно ориентираното програмиране, а именно
- Булеви стойности - Стойност, която е или истина (`#t`), или лъжа(`#f`)
- Числен тип - цели числа (`1`, `-5`), рационални числа (`1/2`, `-4/3`), числа с плаваща запетая и комплексни числа (`1+3i`)
- Букви и символни низове - Буквите(`#\a`, `#\b`) и низовете(`"Hello world"`) са вграден тип , няма нужда да имплементирате големи 5-ци, 4ки и т.н.

## Функции
Както на C++ в Racket имаме функции(процедури), но за разлика от C++, тук те се прилагат в префиксна форма.
Нека да го обясним с пример:
```racket
(+ 2 3) ;; => 5 // Логиката е следната прилагаме + върху 2 и 3
(+ 2 3 5) ;; => 10 // Логиката тук е същата, прилагаме + върху 2, 3 и накрая 5
(/ 12 2 2) ;; => 3 // (12/2) /2 = 3
(= 2 2) ;; => #t
(= 2 1) ;; => #f
(= 5 (+ 2 3)) ;; => #t // Пример за по-сложен израз
```

След като видяхме как да ползваме вградените функции, нека да си дефинираме, няколко наши.

```racket
;; Може да ползваме define за да дефинираме нещо в средата
(define three 3) ;; Така дефинираме променлива забележете няма скоби около името на промнеливата
(define (3+ x) (+ three x)) ;; Така дефинираме функция, в първите скоби пишем името на функцията и имената на параметрите, които ще има.

(3+ 2) ;; => 5, защото (+ 3 2) е 5

(define (compose f x) (f (f x))) ;; Така може да дефинираме функция която приема функция f и аргумент x и връща f.f x

(compose 3+ 1) ;; => 7, защото (+ 3 (+3 1)) -> (+ 3 4) -> 7
```

## Булеви стойности
Пример за функции с аргументи булеви стойности

```racket
(not #t) ;; => #f
(and #t #t) ;; => #t
(and #t #f) ;; => #f
(or #t #f) ;; => #t
(or #f #f #t) ;; => #t
```

## Числа
Пример за функции с аргументи числа

```racket
(max 3 2 1) ;; => 3
(> 3 2) ;; => #t
(>= 3 3) ;; => #t
(+ 2 3) ;; => 5
(* 2 3 5) ;; => 30
(- 12 2 2) ;; => 8
(/ 12 2 2) ;; => 3
```

## Символи и символни низове
Пример за функции с аргументи символи и символни низове
```racket
#\a ;; => символа a
#\newline ;; => нов ред, други възможности са newline и tab
"Hello fp" ;; символен низ
```

## Условни изрази
Ето и формата на условен израз тип if:
```racket
    (if test-expression
        then-expression
        else-expression)
```
И как може да ги ползваме
```racket
    (define (isMeaningOfLife x) 
        (if (= x 42)
            "Yes it is the meaning of life"
            "No this is not the meaning of life"
        )
    )
```
Ако имаме няколко вложени проверки може да ползваме cond, както в C++ е по-удобно да ползваме switch в такива обстоятелства. Това е формата на израза.
```racket
    (cond
        ((check1) (if check1 is true execture expression))
        ((check2) (if check2 is true execture expression))
        ((check3) (if check3 is true execture   expression))
        (else (all other cases execture this expression))
    )
```
Ето и как може да го ползваме.
```racket
    (define (place x)
        (cond
            ((> x 0) "Positive")
            ((= x 0) "Zero")
            (else "Negative")
        )
    )
```

## Рекурсия
Както на C++ може рекурсивно да решим една задача, като ползваме същата функция да решим подзадача на оригиналната задача.
```racket
    (define (harmonic n)
        (if (= n 1) 
            1
            (+ (/ 1 n) (harmonic (- n 1)))))
```

# Задачи Седмица1.

1. Напишете функция (name), която да връща вашето име.
3. Напишете функцията (divide a b), която връща $\lfloor \frac{a}{b} \rfloor$
4. Имплементирайте следните следните функции
`not`
`and`
`or`
`xor`
без да ползвате вградените not, and, or.
5. Напишете функция (repeat n f x), която прилага n пъти функцията f върху x.
6. Ползвайте функцията repeat, която туко що дефинирахме, за да напишете функцията (plus a b), която събира две числа.
7. Имплементирайте функциите succ и pred с един аргумент, които добавят 1 към аргумента си и махат едно от аргумента си
- Предизвикателство 1. Имплементирайте pred, ползвайки само succ
8. Имплементирайте операциите +, -, *, като не ползвате +, -, /, * и други аритметични оператори
- Предизвикателство 1: Направете го без да ползвате директна рекурсия.
9. Имплементирайте операциите mod и факториел, като ползвате само досега позволените и дефинирани неща
- Предизвикателство 1: Направете го без да ползвате директна рекурсия.
